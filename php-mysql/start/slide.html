<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>PHP und MySQL/MariaDB - als Präsentation </title>
	<meta name="viewport" content="width=1024, user-scalable=no">
	
	<!-- Replace path with correct path to deck.core.css. -->
	<link rel="stylesheet" href="/assets/css/deck.core.css" type="text/css">
	<link rel="stylesheet" href="/assets/css/style-theme.css" type="text/css">
	<link rel="stylesheet" href="/assets/css/transition-theme.css" type="text/css">
        <link rel="stylesheet" href="/assets/css/deck.goto.css">
        <link rel="stylesheet" href="/assets/css/deck.status.css">
        <link rel="stylesheet" href="/assets/css/deck.hash.css">
        <link rel="stylesheet" href="/assets/css/style.css">
        <style>
          h4.caption { color: #999999; }
          h4.caption small { color: black; }
          table.table-bordered {
            border-collapse: separate;
          }
          table.table-bordered td,
          table.table-bordered th
          {
            border: 2px white solid;
            padding: 2px;
          }
        </style>
  
	
	<!-- Any other extension CSS files go here. -->
	
	<!-- Replace path with correct path to Modernizr file. -->
	<script src="/assets/js/modernizr.custom.js"></script>
</head>
<body class="deck-container">

<!-- Create any number of elements with class slide within the container -->
          <div class="slide"><h1>PHP und MySQL/MariaDB</h1>
          <p><a href="/php-mysql/start/">zurück zum Buch-Kapitel</a></p>
          </div>
	  <div class='slide'><p>Mit der Verwendung einer Datenbank wird der Aufruf einer
Webseite noch einmal komplexer:  der Webserver ruft
das PHP Programm auf, das PHP-Programm schickt eine
Anfrage an die Datenbank.</p>

<p><img src="/images/php-db.svg" alt="Webseite wird von PHP erzeugt, mit DB-Abfrage" /></p>

<p>Ob der Datenbank-Server und der Webserver auf dem selben Computer laufen
oder auf verschiedenen macht für die Programmierung kaum einen Unterschied.</p>

</div>
<div class='slide'>

<h2 id="mysql-von-php-aus">MySQL von PHP aus</h2>

<p>Um von PHP auf die Datenbank zuzugreifen gibt es verschiedene Schnittstellen. 
Hier werden die „PHP Database Objects“ (PDO) vorgestellt, siehe auch
<a href="http://php.net/manual/de/book.pdo.php">PDO Dokumentation</a>.</p>

</div>
<div class='slide'>

<h3 id="verbindungsaufbau">Verbindungsaufbau</h3>

<p>So funktioniert der Verbindung-Aufbau (und -Abbau) zur mysql-Datenbank:</p>

<div class="example">
<h4 class="caption">Php Code <small>Verbindungs-Aufbau und Abbau</small></h4>
<pre class="lang-php prettyprint linenums">
    &lt;?
     include &quot;config.php&quot;;
     $dbh = new PDO($DSN, $DB_USER, $DB_PASS);
     $dbh-&gt;exec('SET CHARACTER SET utf8');
    ?&gt; 
</pre></div>

<p>Das „Database-Handle“ <code>$dbh</code> wird nun im Weiteren für Abfragen verwendet. </p>

</div>
<div class='slide'>

<h3 id="datenbank-zugangsdaten-und-gitignore">Datenbank-Zugangsdaten und .gitignore</h3>

<p>Achtung: zum Erzeugen des Database Handles brauchen wir noch eine zweite Datei mit den eigentlichen Zugangsdaten. Diese Datei heisst im unserem Beispiel <code>config.php</code>:</p>

<div class="example">
<h4 class="caption">Php Code <small>Zugangsdaten für die Datenbank</small></h4>
<pre class="lang-php prettyprint linenums">
    &lt;?php
    $DB_NAME = &quot;portfolio_playground&quot;; 
    $DB_USER = &quot;mmtuser&quot;; 
    $DB_PASS = &quot;geheim!&quot;;
    $DSN     = &quot;mysql:dbname=$DB_NAME;host=localhost&quot;;
    ?&gt;
</pre></div>

<p>Warum zwei Dateien?  Weil dieses zweite Datei niemals, niemals, niemals in git commited werden darf!  Um das zu verhindern, wird die Datei in <code>.gitignore</code> eingetragen. Was das bewirkt zeigt der Vorher / Nachher-Vergleich am besten:</p>

<pre><code>D:\Webprojekte\wp2&gt;git status

# On branch master
# Your branch is ahead of 'origin/master' by 2 commits.
#
# Untracked files:
#   (use "git add &lt;file&gt;..." to include in what will be committed)
#
#       config.php
nothing added to commit but untracked files present (use "git add" to track)
</code></pre>

<p>Hier erkennt git die datei <code>config.php</code> als neue, interessante Datei. Nun tragen wir den Dateinamen <code>config.php</code> in die Datei <code>.gitignore</code> im Haupt-Ordner der Working Copy ein:</p>

<pre><code>D:\Webprojekte\wp2&gt;cat .gitignore
*.bak
config.php
</code></pre>

<p>Damit ist git angewiesen, alle Dateien mit der Endung <code>.bak</code> und alle Dateien mit dem Namen <code>config.php</code> (egal in welchem Ordner) zu ignorieren. </p>

<pre><code>D:\Webprojekte\wp2&gt;git status

# On branch master
# Your branch is ahead of 'origin/master' by 2 commits.
#
# Changed but not updated:
#   (use "git add &lt;file&gt;..." to update what will be committed)
#   (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)
#
#       modified:   .gitignore
#
no changes added to commit (use "git add" and/or "git commit -a")
</code></pre>

<p>Wie man sieht zeigt <code>git status</code> nun die Datei <code>config.php</code> nicht mehr an. Dafür hat git bemerkt dass die Datei <code>.gitignore</code> geändert wurde. Die sollte man ganz normal commiten.</p>

</div>
<div class='slide'>

<h3 id="anweisung-an-die-datenbank">Anweisung an die Datenbank</h3>

<p>Manche SQL-Queries liefern keine Daten retour.
Solche Queries kann man mit der Methode <code>exec</code> absetzen:</p>

<div class="example">
<h4 class="caption">Php Code <small>Anweisungen an die Datenbank mit exec</small></h4>
<pre class="lang-php prettyprint linenums">
$dbh = new PDO(…);
dbh-&gt;exec(&quot;DELETE FROM users&quot;);
</pre></div>

<p>Hier werden alle Datensätze aus der Tabelle <code>users</code> gelöscht,
es gibt keine Rückmeldung an PHP.</p>

</div>
<div class='slide'>

<h3 id="abfrage-mit-select">Abfrage mit Select</h3>

<p>Eine Abfrage aus der Datenbank liefert normalerweise eine ganze Tabelle von Daten (mehrere Datensätze). Man braucht also eine Schleife um alle Datensätze abzuarbeiten. Innerhalb der Schleife erhält man den einzelnen Datensatz als Array. </p>

<div class="example">
<h4 class="caption">Php Code <small>Abfrage der Datenbank mit SELECT</small></h4>
<pre class="lang-php prettyprint linenums">
    $query =$dbh-&gt;query(
         &quot;SELECT * FROM person WHERE ifshow=1 ORDER BY RAND() LIMIT 1,10&quot;
    );
    $personen = $query-&gt;fetchAll(PDO::FETCH_OBJ);
    foreach($personen as $person) {

          echo &quot;$person-&gt;vorname $person-&gt;mail&lt;/br&gt;\n&quot;;
    }
</pre></div>

<p>Die SQL-Anfrage wird hier als String an die query-methode des Datenbankhandler übergeben.  Der Rückgabewert von query ist ein Query-Handle <code>$query</code> (ähnlich dem Datenbank-Handle).  Zu diesem Zeitpunkt wurden noch keine Daten von der Datenbank zu PHP übertragen. Das passiert erst in der nächsten Zeile mit der Methode <code>fetchAll</code>. Der Rückgabewert von fetchAll ist in diesem Fall ein Array mit Objekten. Dieses Array wird anschließend mit einer foreach-Schleife abgearbeitet. </p>

</div>
<div class='slide'>

<h2 id="effizient-arbeiten-mit-der-datenbank">Effizient Arbeiten mit der Datenbank</h2>

<p>Ein ganz wichtiges Grundprinzip beim Programmieren mit Datenbanken: Das Filtern und Berechnen der Daten möglichst in der Datenbank erledigen und möglichst wenige Daten zu PHP übermitteln. Folgender Ansatz wäre also ganz schlecht, besonders wenn viele Daten in der Datenbank sind:</p>

<div class="example">
<h4 class="caption">Php Code <small>Ineffiziente Abfrage der Datenbank</small></h4>
<pre class="lang-php prettyprint linenums">
$query =$dbh-&gt;query(&quot;SELECT * FROM person&quot;);
$personen = $query-&gt;fetchAll(PDO::FETCH_OBJ);
foreach($personen as $person ) {
  if($person-&gt;ifshow) {
    echo &quot;$person-&gt;vorname $person-&gt;mail&lt;/br&gt;\n&quot;;
  }
}
</pre></div>

</div>
<div class='slide'>



<p>Besser wäre, den Filter bereits im SELECT einzubauen:</p>

<div class="example">
<h4 class="caption">Php Code <small>Effiziente Abfrage der Datenbank</small></h4>
<pre class="lang-php prettyprint linenums">
$query =$dbh-&gt;query(&quot;SELECT * FROM person WHERE ifshow&quot;);
$personen = $query-&gt;fetchAll(PDO::FETCH_OBJ);
foreach($personen as $person ) {
  echo &quot;$person-&gt;vorname $person-&gt;mail&lt;/br&gt;\n&quot;;
}
</pre></div>

</div>
<div class='slide'>



<p>Die gleichen Überlegungen gelten auch, wenn Datensätze “Seitenweise” angezeigt
werden sollen: hier verwendet man bereits in der Datenbank <code>LIMIT</code> um nur
die beötigten Datensätze zu laden.</p>

</div>
<div class='slide'>



<p>Die Verwendung der richtigen Datentypen in der Datenbank erleichtert die Abfragen:  zum Beipiel zum Speichern eines Datums DATE oder TIMESTAMP verwenden. Das ermöglicht das Sortieren nach Datum und  Berechnungen wie „falls datum nicht älter als 100 Tage alt ist“</p>

<div class="example">
<pre class="lang-sql prettyprint linenums">
  select titel,pub_datum from werk 
  where datediff( curdate( ) , pub_datum ) &lt;= 100; 
</pre></div>

<p>Zeigt Titel und Publikations-Datum aller Werke die in den letzten 100 Tagen publiziert wurden.</p>
</div>
          <div class="slide"><h1>Ende</h1>
          <p><a href="/php-mysql/start/">zurück zum Buch-Kapitel</a></p>
          </div>
	
<!-- Other extension HTML snippets go here, at the bottom of the deck container. -->
<!-- deck.status snippet -->
<p class="deck-status">
  <span class="deck-status-current"></span>
  /
  <span class="deck-status-total"></span>
</p>

<!-- deck.hash snippet -->
<a href="." title="Permalink to this slide" class="deck-permalink">#</a>

<!-- Update these paths to point to the correct files. -->
<script src="/assets/js/modernizr.custom.js"></script>
<script src="/assets/js/jquery.min.js"></script>
<script src="/assets/js/deck.core.js"></script>
<script src="/assets/js/deck.hash.js"></script>
<script src="/assets/js/deck.goto.js"></script>
<script src="/assets/js/deck.status.js"></script>

<!-- Add any other extension JS files here -->


<!-- Initialize the deck. You can put this in an external file if desired. -->
<script>
	$(function() {
		$.deck('.slide');
	});
</script>
</body>
</html>
